<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>Ninja Stealth — Browser Demo</title>
  <style>
    html,body{margin:0;padding:0;background:#000;color:#fff;font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial}
    canvas{display:block;margin:0 auto;touch-action:none}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.js"></script>
</head>
<body>
<script>
/*
  Полностью автономная версия без внешних картинок.
  Свет реализован маской (работает в WebGL и Canvas). Оптимизировано для iPhone.
*/

class NinjaScene extends Phaser.Scene {
  constructor(){ super('NinjaScene'); }

  preload(){
    // Ничего не грузим извне. Всё рисуем кодом.
  }

  create(){
    // Размеры сцены
    this.W = 800; this.H = 600;

    // ФИЗИКА
    this.physics.world.setBounds(0,0,this.W,this.H);

    // БЭКГРАУНД (градиент стен замка)
    const bg = this.add.graphics();
    const g = bg;
    for(let i=0;i<this.H;i+=2){
      const c = 15 + Math.floor(25*Math.sin(i/80));
      g.fillStyle(Phaser.Display.Color.GetColor(c,c,c+20),1);
      g.fillRect(0,i,this.W,2);
    }
    // Каменные "блоки"
    const stones = this.add.graphics();
    stones.lineStyle(1,0x222222,0.6);
    for(let y=60;y<this.H;y+=60){
      stones.lineBetween(0,y,this.W,y);
      for(let x=(y/60)%2?30:0; x<this.W; x+=60){
        stones.lineBetween(x,y-60,x,y);
      }
    }

    // ПЛАТФОРМЫ
    this.platforms = [];
    const addPlatform = (x,y,w,h,color=0x4b3a2a)=>{
      const rect = this.add.rectangle(x,y,w,h,color).setOrigin(0.5,0.5);
      this.physics.add.existing(rect,true); // static
      this.platforms.push(rect);
      return rect;
    };
    // земля и несколько выступов
    addPlatform(400,585,800,30,0x3b2a1a);
    addPlatform(300,460,200,20,0x3b2a1a);
    addPlatform(650,390,220,20,0x3b2a1a);
    addPlatform(120,340,150,20,0x3b2a1a);

    // ФАКЕЛ (как ориентир света)
    this.torch = this.add.container(400,520);
    const pole = this.add.rectangle(0,10,10,60,0x5a3a1a);
    const flame = this.add.circle(0,-10,12,0xffaa00);
    this.torch.add([pole,flame]);
    this.torch.setDepth(5);
    this.torchRadius = 180;
    this.torchAlive = true;

    // ИГРОК-НИНДЗЯ (прямоугольник + "повязка")
    this.player = this.add.container(100,450);
    const body = this.add.rectangle(0,0,26,34,0x111111);
    const band = this.add.rectangle(0,-10,20,4,0xff2233);
    this.player.add([body,band]);
    this.physics.add.existing(this.player);
    this.player.body.setSize(26,34).setOffset(-13,-17);
    this.player.body.setCollideWorldBounds(true);
    this.playerSpeed = 170;
    this.playerJump = -330;
    this.isFacingRight = true;

    // ВРАГИ-РЫЦАРИ
    this.enemies = [];
    const addKnight = (x,y,patrolMin,patrolMax)=>{
      const knight = this.add.container(x,y);
      const armor = this.add.rectangle(0,0,28,36,0xb0b0c0);
      const plume = this.add.rectangle(0,-18,18,6,0x8890ff);
      knight.add([armor,plume]);
      this.physics.add.existing(knight);
      knight.body.setSize(28,36).setOffset(-14,-18);
      knight.body.setCollideWorldBounds(true);
      knight.patrolMin = patrolMin;
      knight.patrolMax = patrolMax;
      knight.dir = -1;
      knight.speed = 45;
      knight.vision = 160;
      this.enemies.push(knight);
      return knight;
    };
    addKnight(600,450,520,720);
    addKnight(260,430,220,380);

    // КОЛЛАЙДЕРЫ
    this.platforms.forEach(p=>{
      this.physics.add.collider(this.player,p);
      this.enemies.forEach(k=>this.physics.add.collider(k,p));
    });

    // ПЕРЕСЕЧЕНИЯ И АТАКА
    this.attackKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    this.interactKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);
    this.enemies.forEach(k=>{
      this.physics.add.overlap(this.player,k,(pl,kn)=>this.handleOverlap(pl,kn));
    });

    // ИНДИКАТОР ЗАМЕТНОСТИ
    this.alertLevel = 0;
    this.alertBg = this.add.rectangle(this.W/2,22,410,16,0x222222).setOrigin(0.5,0.5).setScrollFactor(0).setDepth(20);
    this.alertBar = this.add.rectangle(this.W/2-200,22,0,12,0xff3344).setOrigin(0,0.5).setScrollFactor(0).setDepth(20);
    this.add.text(this.W/2-200,36,'Заметность', {font:'12px system-ui', fill:'#ccc'}).setDepth(20);

    // УПРАВЛЕНИЕ (клавиатура)
    this.cursors = this.input.keyboard.createCursorKeys();

    // ТАЧ-КНОПКИ (айфон)
    this.createTouchControls();

    // ТЁМНОТА + СВЕТ (маска)
    this.darkness = this.add.graphics().setDepth(10);
    this.lightMask = this.make.graphics({x:0,y:0,add:false});
    const geomMask = this.lightMask.createGeometryMask();
    geomMask.setInvertAlpha(true);
    this.darkness.setMask(geomMask);
  }

  createTouchControls(){
    this.input.addPointer(2);
    const alpha=0.18, line=0xaaaaaa;

    // Лево/право
    this.leftBtn = this.add.circle(80,520,46,0xffffff,alpha).setStrokeStyle(2,line).setDepth(30).setInteractive();
    this.rightBtn= this.add.circle(160,520,46,0xffffff,alpha).setStrokeStyle(2,line).setDepth(30).setInteractive();
    this.jumpBtn = this.add.circle(720,520,46,0xffffff,alpha).setStrokeStyle(2,line).setDepth(30).setInteractive();
    this.actBtn  = this.add.circle(640,520,46,0xffffff,alpha).setStrokeStyle(2,line).setDepth(30).setInteractive();

    const hold = (obj, on, off)=>{
      obj.on('pointerdown',()=>on(true));
      obj.on('pointerup',()=>off(false));
      obj.on('pointerout',()=>off(false));
      obj.on('pointercancel',()=>off(false));
    };
    this.holdLeft=false; this.holdRight=false; this.holdJump=false; this.holdAct=false;
    hold(this.leftBtn, v=>this.holdLeft=v, v=>this.holdLeft=v);
    hold(this.rightBtn,v=>this.holdRight=v,v=>this.holdRight=v);
    hold(this.jumpBtn, v=>this.holdJump=v, v=>this.holdJump=v);
    hold(this.actBtn,  v=>this.holdAct=v,  v=>this.holdAct=v);
  }

  handleOverlap(player, knight){
    const close = Phaser.Math.Distance.Between(player.x,player.y,knight.x,knight.y) < 38;
    const behind = (knight.dir===1 && player.x < knight.x) || (knight.dir===-1 && player.x > knight.x);
    const actPressed = this.attackKey.isDown || this.holdAct;

    if (actPressed && close && behind){
      // Скрытое устранение
      this.enemies = this.enemies.filter(k=>k!==knight);
      knight.destroy();
      this.alertLevel = Math.max(0, this.alertLevel - 40);
    } else {
      // Замечен близко
      this.alertLevel = Math.min(100, this.alertLevel + 35);
    }
  }

  update(time, delta){
    const dt = delta/1000;

    // === УПРАВЛЕНИЕ ===
    const left = this.cursors.left.isDown || this.holdLeft;
    const right = this.cursors.right.isDown || this.holdRight;
    const onFloor = this.player.body.onFloor();
    if (left){ this.player.body.setVelocityX(-this.playerSpeed); this.isFacingRight=false; }
    else if (right){ this.player.body.setVelocityX(this.playerSpeed); this.isFacingRight=true; }
    else { this.player.body.setVelocityX(0); }

    if ((this.cursors.up.isDown || this.holdJump) && onFloor){
      this.player.body.setVelocityY(this.playerJump);
    }

    // === ВРАГИ ПАТРУЛЬ + ВИДИМОСТЬ ===
    const torchR = this.torchAlive ? this.torchRadius : 0;
    let visibleToEnemy = false;

    this.enemies.forEach(kn=>{
      // патруль
      kn.body.setVelocityX(kn.speed * kn.dir);
      if (kn.x < kn.patrolMin){ kn.dir = 1; }
      if (kn.x > kn.patrolMax){ kn.dir = -1; }

      // видимость (в конусе перед рыцарем + в свете факела)
      const dist = Phaser.Math.Distance.Between(this.player.x,this.player.y,kn.x,kn.y);
      const lookingRight = kn.dir===1;
      const inFront = (lookingRight && this.player.x>=kn.x) || (!lookingRight && this.player.x<=kn.x);
      const inTorchLight = this.torchAlive && Phaser.Math.Distance.Between(this.player.x,this.player.y,this.torch.x,this.torch.y) < torchR;
      if (dist<kn.vision && inFront && inTorchLight){
        visibleToEnemy = true;
      }
    });

    // тушение факела (E / act)
    const nearTorch = Phaser.Math.Distance.Between(this.player.x,this.player.y,this.torch.x,this.torch.y) < 48;
    if (nearTorch && (this.interactKey.isDown || this.holdAct) && this.torchAlive){
      this.torchAlive=false;
      this.torchRadius=0;
      // меняем визуально огонь на серый
      this.torch.removeAll(true);
      const pole = this.add.rectangle(0,10,10,60,0x5a3a1a);
      const cap  = this.add.circle(0,-10,10,0x444444);
      this.torch.add([pole,cap]);
    }

    // === ЗАМЕТНОСТЬ ===
    if (visibleToEnemy){
      this.alertLevel = Math.min(100, this.alertLevel + 25*dt);
    } else {
      this.alertLevel = Math.max(0, this.alertLevel - 20*dt);
    }
    this.alertBar.width = 4.1 * this.alertLevel;

    // === СВЕТ/ТЕНИ — маска ===
    this.darkness.clear();
    this.darkness.fillStyle(0x000000, 0.86);
    this.darkness.fillRect(0,0,this.W,this.H);

    this.lightMask.clear();
    this.lightMask.fillStyle(0xffffff,1);
    if (this.torchAlive){
      // основной свет факела
      this.lightMask.fillCircle(this.torch.x, this.torch.y-20, this.torchRadius);
      // мягкая кайма
      this.lightMask.fillStyle(0x888888,1);
      this.lightMask.fillCircle(this.torch.x, this.torch.y-20, this.torchRadius*0.66);
    }
    // слабый контур вокруг игрока (видимость на 1-2 метра)
    this.lightMask.fillStyle(0x777777,1);
    this.lightMask.fillCircle(this.player.x, this.player.y-10, 60);

    // === ПРОВАЛ / ПОБЕДА (простая логика) ===
    if (this.alertLevel>=100){
      this.scene.restart(); // перезапуск уровня при провале
    }
  }
}

const config = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  backgroundColor: '#000000',
  physics: { default: 'arcade', arcade: { gravity: { y: 520 }, debug:false } },
  scene: [NinjaScene]
};

new Phaser.Game(config);
</script>
</body>
</html>
